import React, { useState, useRef, useEffect } from 'react';
import { 
  MessageCircle, 
  X, 
  Send, 
  Mic, 
  MicOff, 
  Volume2, 
  VolumeX, 
  Globe,
  Bot,
  User,
  Minimize2,
  Maximize2,
  RefreshCw,
  Square,
  Play
} from 'lucide-react';
import Button from '../common/Button';

interface Message {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
  language?: string;
}

interface AIHealthAssistantProps {
  isOpen: boolean;
  onToggle: () => void;
}

const AIHealthAssistant: React.FC<AIHealthAssistantProps> = ({ isOpen, onToggle }) => {
  const [selectedLanguage, setSelectedLanguage] = useState('hi');
  const [messages, setMessages] = useState<Message[]>([]);
  
  const [inputMessage, setInputMessage] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [isListening, setIsListening] = useState(false);
  const [isSpeaking, setIsSpeaking] = useState(false);
  const [isMinimized, setIsMinimized] = useState(false);
  const [voiceInputEnabled, setVoiceInputEnabled] = useState(true);
  const [autoSpeak, setAutoSpeak] = useState(true);
  
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);
  const recognitionRef = useRef<any>(null);
  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const audioChunksRef = useRef<Blob[]>([]);

  // All Indian languages supported
  const languages = [
    { code: 'hi', name: '‡§π‡§ø‡§Ç‡§¶‡•Ä', flag: 'üáÆüá≥', greeting: '‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Æ‡•à‡§Ç CareMate ‡§π‡•Ç‡§Ç, ‡§Ü‡§™‡§ï‡§æ AI ‡§∏‡•ç‡§µ‡§æ‡§∏‡•ç‡§•‡•ç‡§Ø ‡§∏‡§π‡§æ‡§Ø‡§ï‡•§ ‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•á ‡§∏‡•ç‡§µ‡§æ‡§∏‡•ç‡§•‡•ç‡§Ø ‡§∏‡§Ç‡§¨‡§Ç‡§ß‡•Ä ‡§™‡•ç‡§∞‡§∂‡•ç‡§®‡•ã‡§Ç ‡§ï‡§æ ‡§â‡§§‡•ç‡§§‡§∞ ‡§¶‡•á ‡§∏‡§ï‡§§‡§æ ‡§π‡•Ç‡§Ç‡•§ ‡§Ü‡§ú ‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•Ä ‡§ï‡•à‡§∏‡•á ‡§∏‡§π‡§æ‡§Ø‡§§‡§æ ‡§ï‡§∞ ‡§∏‡§ï‡•Ç‡§Ç?' },
    { code: 'en', name: 'English', flag: 'üáÆüá≥', greeting: 'Hello! I am CareMate, your AI Health Assistant. I can help answer your health-related questions. How can I assist you today?' },
    { code: 'bn', name: '‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ', flag: 'üáÆüá≥', greeting: '‡¶®‡¶Æ‡¶∏‡ßç‡¶ï‡¶æ‡¶∞! ‡¶Ü‡¶Æ‡¶ø CareMate, ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ AI ‡¶∏‡ßç‡¶¨‡¶æ‡¶∏‡ßç‡¶•‡ßç‡¶Ø ‡¶∏‡¶π‡¶æ‡¶Ø‡¶º‡¶ï‡•§ ‡¶Ü‡¶Æ‡¶ø ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶∏‡ßç‡¶¨‡¶æ‡¶∏‡ßç‡¶•‡ßç‡¶Ø ‡¶∏‡¶Æ‡ßç‡¶™‡¶∞‡ßç‡¶ï‡¶ø‡¶§ ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶®‡ßá‡¶∞ ‡¶â‡¶§‡ßç‡¶§‡¶∞ ‡¶¶‡¶ø‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶ø‡•§ ‡¶Ü‡¶ú ‡¶Ü‡¶Æ‡¶ø ‡¶Ü‡¶™‡¶®‡¶æ‡¶ï‡ßá ‡¶ï‡ßÄ‡¶≠‡¶æ‡¶¨‡ßá ‡¶∏‡¶æ‡¶π‡¶æ‡¶Ø‡ßç‡¶Ø ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶ø?' },
    { code: 'te', name: '‡∞§‡±Ü‡∞≤‡±Å‡∞ó‡±Å', flag: 'üáÆüá≥', greeting: '‡∞®‡∞Æ‡∞∏‡±ç‡∞ï‡∞æ‡∞∞‡∞Ç! ‡∞®‡±á‡∞®‡±Å CareMate, ‡∞Æ‡±Ä AI ‡∞Ü‡∞∞‡±ã‡∞ó‡±ç‡∞Ø ‡∞∏‡∞π‡∞æ‡∞Ø‡∞ï‡±Å‡∞°‡∞ø‡∞®‡∞ø‡•§ ‡∞®‡±á‡∞®‡±Å ‡∞Æ‡±Ä ‡∞Ü‡∞∞‡±ã‡∞ó‡±ç‡∞Ø ‡∞∏‡∞Ç‡∞¨‡∞Ç‡∞ß‡∞ø‡∞§ ‡∞™‡±ç‡∞∞‡∞∂‡±ç‡∞®‡∞≤‡∞ï‡±Å ‡∞∏‡∞Æ‡∞æ‡∞ß‡∞æ‡∞®‡∞Ç ‡∞á‡∞µ‡±ç‡∞µ‡∞ó‡∞≤‡∞®‡±Å. ‡∞à‡∞∞‡±ã‡∞ú‡±Å ‡∞®‡±á‡∞®‡±Å ‡∞Æ‡±Ä‡∞ï‡±Å ‡∞é‡∞≤‡∞æ ‡∞∏‡∞π‡∞æ‡∞Ø‡∞Ç ‡∞ö‡±á‡∞Ø‡∞ó‡∞≤‡∞®‡±Å?' },
    { code: 'mr', name: '‡§Æ‡§∞‡§æ‡§†‡•Ä', flag: 'üáÆüá≥', greeting: '‡§®‡§Æ‡§∏‡•ç‡§ï‡§æ‡§∞! ‡§Æ‡•Ä CareMate ‡§Ü‡§π‡•á, ‡§§‡•Å‡§Æ‡§ö‡§æ AI ‡§Ü‡§∞‡•ã‡§ó‡•ç‡§Ø ‡§∏‡§π‡§æ‡§Ø‡•ç‡§Ø‡§ï. ‡§Æ‡•Ä ‡§§‡•Å‡§Æ‡§ö‡•ç‡§Ø‡§æ ‡§Ü‡§∞‡•ã‡§ó‡•ç‡§Ø ‡§∏‡§Ç‡§¨‡§Ç‡§ß‡•Ä ‡§™‡•ç‡§∞‡§∂‡•ç‡§®‡§æ‡§Ç‡§ö‡•Ä ‡§â‡§§‡•ç‡§§‡§∞‡•á ‡§¶‡•á‡§ä ‡§∂‡§ï‡§§‡•ã. ‡§Ü‡§ú ‡§Æ‡•Ä ‡§§‡•Å‡§Æ‡•ç‡§π‡§æ‡§≤‡§æ ‡§ï‡§∂‡•Ä ‡§Æ‡§¶‡§§ ‡§ï‡§∞‡•Ç ‡§∂‡§ï‡§§‡•ã?' },
    { code: 'ta', name: '‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç', flag: 'üáÆüá≥', greeting: '‡Æµ‡Æ£‡Æï‡Øç‡Æï‡ÆÆ‡Øç! ‡Æ®‡Ææ‡Æ©‡Øç CareMate, ‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç AI ‡Æö‡ØÅ‡Æï‡Ææ‡Æ§‡Ææ‡Æ∞ ‡Æâ‡Æ§‡Æµ‡Æø‡ÆØ‡Ææ‡Æ≥‡Æ∞‡Øç. ‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æö‡ØÅ‡Æï‡Ææ‡Æ§‡Ææ‡Æ∞ ‡Æ§‡Øä‡Æü‡Æ∞‡Øç‡Æ™‡Ææ‡Æ© ‡Æï‡Øá‡Æ≥‡Øç‡Æµ‡Æø‡Æï‡Æ≥‡ØÅ‡Æï‡Øç‡Æï‡ØÅ ‡Æé‡Æ©‡Øç‡Æ©‡Ææ‡Æ≤‡Øç ‡Æ™‡Æ§‡Æø‡Æ≤‡Æ≥‡Æø‡Æï‡Øç‡Æï ‡ÆÆ‡ØÅ‡Æü‡Æø‡ÆØ‡ØÅ‡ÆÆ‡Øç. ‡Æá‡Æ©‡Øç‡Æ±‡ØÅ ‡Æ®‡Ææ‡Æ©‡Øç ‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡ØÅ‡Æï‡Øç‡Æï‡ØÅ ‡Æé‡Æ™‡Øç‡Æ™‡Æü‡Æø ‡Æâ‡Æ§‡Æµ ‡ÆÆ‡ØÅ‡Æü‡Æø‡ÆØ‡ØÅ‡ÆÆ‡Øç?' },
    { code: 'gu', name: '‡™ó‡´Å‡™ú‡™∞‡™æ‡™§‡´Ä', flag: 'üáÆüá≥', greeting: '‡™®‡™Æ‡™∏‡´ç‡™§‡´á! ‡™π‡´Å‡™Ç CareMate ‡™õ‡´Å‡™Ç, ‡™§‡™Æ‡™æ‡™∞‡´ã AI ‡™Ü‡™∞‡´ã‡™ó‡´ç‡™Ø ‡™∏‡™π‡™æ‡™Ø‡™ï. ‡™π‡´Å‡™Ç ‡™§‡™Æ‡™æ‡™∞‡™æ ‡™Ü‡™∞‡´ã‡™ó‡´ç‡™Ø ‡™∏‡™Ç‡™¨‡™Ç‡™ß‡™ø‡™§ ‡™™‡´ç‡™∞‡™∂‡´ç‡™®‡´ã‡™®‡™æ ‡™ú‡™µ‡™æ‡™¨ ‡™Ü‡™™‡´Ä ‡™∂‡™ï‡´Å‡™Ç ‡™õ‡´Å‡™Ç. ‡™Ü‡™ú‡´á ‡™π‡´Å‡™Ç ‡™§‡™Æ‡™æ‡™∞‡´Ä ‡™ï‡´á‡™µ‡´Ä ‡™∞‡´Ä‡™§‡´á ‡™Æ‡™¶‡™¶ ‡™ï‡™∞‡´Ä ‡™∂‡™ï‡´Å‡™Ç?' },
    { code: 'kn', name: '‡≤ï‡≤®‡≥ç‡≤®‡≤°', flag: 'üáÆüá≥', greeting: '‡≤®‡≤Æ‡≤∏‡≥ç‡≤ï‡≤æ‡≤∞! ‡≤®‡≤æ‡≤®‡≥Å CareMate, ‡≤®‡≤ø‡≤Æ‡≥ç‡≤Æ AI ‡≤Ü‡≤∞‡≥ã‡≤ó‡≥ç‡≤Ø ‡≤∏‡≤π‡≤æ‡≤Ø‡≤ï. ‡≤®‡≤ø‡≤Æ‡≥ç‡≤Æ ‡≤Ü‡≤∞‡≥ã‡≤ó‡≥ç‡≤Ø ‡≤∏‡≤Ç‡≤¨‡≤Ç‡≤ß‡≤ø‡≤§ ‡≤™‡≥ç‡≤∞‡≤∂‡≥ç‡≤®‡≥Ü‡≤ó‡≤≥‡≤ø‡≤ó‡≥Ü ‡≤®‡≤æ‡≤®‡≥Å ‡≤â‡≤§‡≥ç‡≤§‡≤∞‡≤ø‡≤∏‡≤¨‡≤≤‡≥ç‡≤≤‡≥Ü. ‡≤á‡≤Ç‡≤¶‡≥Å ‡≤®‡≤æ‡≤®‡≥Å ‡≤®‡≤ø‡≤Æ‡≤ó‡≥Ü ‡≤π‡≥á‡≤ó‡≥Ü ‡≤∏‡≤π‡≤æ‡≤Ø ‡≤Æ‡≤æ‡≤°‡≤¨‡≤π‡≥Å‡≤¶‡≥Å?' },
    { code: 'ml', name: '‡¥Æ‡¥≤‡¥Ø‡¥æ‡¥≥‡¥Ç', flag: 'üáÆüá≥', greeting: '‡¥®‡¥Æ‡¥∏‡µç‡¥ï‡¥æ‡¥∞‡¥Ç! ‡¥û‡¥æ‡µª CareMate ‡¥Ü‡¥£‡µç, ‡¥®‡¥ø‡¥ô‡µç‡¥ô‡¥≥‡µÅ‡¥ü‡µÜ AI ‡¥Ü‡¥∞‡µã‡¥ó‡µç‡¥Ø ‡¥∏‡¥π‡¥æ‡¥Ø‡¥ø. ‡¥®‡¥ø‡¥ô‡µç‡¥ô‡¥≥‡µÅ‡¥ü‡µÜ ‡¥Ü‡¥∞‡µã‡¥ó‡µç‡¥Ø ‡¥∏‡¥Ç‡¥¨‡¥®‡µç‡¥ß‡¥ø‡¥Ø‡¥æ‡¥Ø ‡¥ö‡µã‡¥¶‡µç‡¥Ø‡¥ô‡µç‡¥ô‡µæ‡¥ï‡µç‡¥ï‡µç ‡¥é‡¥®‡¥ø‡¥ï‡µç‡¥ï‡µç ‡¥â‡¥§‡µç‡¥§‡¥∞‡¥Ç ‡¥®‡µΩ‡¥ï‡¥æ‡µª ‡¥ï‡¥¥‡¥ø‡¥Ø‡µÅ‡¥Ç. ‡¥á‡¥®‡µç‡¥®‡µç ‡¥û‡¥æ‡µª ‡¥®‡¥ø‡¥ô‡µç‡¥ô‡¥≥‡µÜ ‡¥é‡¥ô‡µç‡¥ô‡¥®‡µÜ ‡¥∏‡¥π‡¥æ‡¥Ø‡¥ø‡¥ï‡µç‡¥ï‡¥æ‡¥Ç?' },
    { code: 'pa', name: '‡®™‡©∞‡®ú‡®æ‡®¨‡©Ä', flag: 'üáÆüá≥', greeting: '‡®∏‡®§ ‡®∏‡©ç‡®∞‡©Ä ‡®Ö‡®ï‡®æ‡®≤! ‡®Æ‡©à‡®Ç CareMate ‡®π‡®æ‡®Ç, ‡®§‡©Å‡®π‡®æ‡®°‡®æ AI ‡®∏‡®ø‡®π‡®§ ‡®∏‡®π‡®æ‡®á‡®ï‡•§ ‡®Æ‡©à‡®Ç ‡®§‡©Å‡®π‡®æ‡®°‡©á ‡®∏‡®ø‡®π‡®§ ‡®∏‡©∞‡®¨‡©∞‡®ß‡©Ä ‡®∏‡®µ‡®æ‡®≤‡®æ‡®Ç ‡®¶‡©á ‡®ú‡®µ‡®æ‡®¨ ‡®¶‡©á ‡®∏‡®ï‡®¶‡®æ ‡®π‡®æ‡®Ç‡•§ ‡®Ö‡©±‡®ú ‡®Æ‡©à‡®Ç ‡®§‡©Å‡®π‡®æ‡®°‡©Ä ‡®ï‡®ø‡®µ‡©á‡®Ç ‡®Æ‡®¶‡®¶ ‡®ï‡®∞ ‡®∏‡®ï‡®¶‡®æ ‡®π‡®æ‡®Ç?' },
    { code: 'or', name: '‡¨ì‡¨°‡¨º‡¨ø‡¨Ü', flag: 'üáÆüá≥', greeting: '‡¨®‡¨Æ‡¨∏‡≠ç‡¨ï‡¨æ‡¨∞! ‡¨Æ‡≠Å‡¨Å CareMate, ‡¨Ü‡¨™‡¨£‡¨ô‡≠ç‡¨ï‡¨∞ AI ‡¨∏‡≠ç‡≠±‡¨æ‡¨∏‡≠ç‡¨•‡≠ç‡≠ü ‡¨∏‡¨π‡¨æ‡≠ü‡¨ï‡•§ ‡¨Æ‡≠Å‡¨Å ‡¨Ü‡¨™‡¨£‡¨ô‡≠ç‡¨ï‡¨∞ ‡¨∏‡≠ç‡≠±‡¨æ‡¨∏‡≠ç‡¨•‡≠ç‡≠ü ‡¨∏‡¨Æ‡≠ç‡¨¨‡¨®‡≠ç‡¨ß‡≠Ä‡≠ü ‡¨™‡≠ç‡¨∞‡¨∂‡≠ç‡¨®‡¨∞ ‡¨â‡¨§‡≠ç‡¨§‡¨∞ ‡¨¶‡≠á‡¨á‡¨™‡¨æ‡¨∞‡¨ø‡¨¨‡¨ø‡•§ ‡¨Ü‡¨ú‡¨ø ‡¨Æ‡≠Å‡¨Å ‡¨Ü‡¨™‡¨£‡¨ô‡≠ç‡¨ï‡≠Å ‡¨ï‡¨ø‡¨™‡¨∞‡¨ø ‡¨∏‡¨æ‡¨π‡¨æ‡¨Ø‡≠ç‡≠ü ‡¨ï‡¨∞‡¨ø‡¨™‡¨æ‡¨∞‡¨ø‡¨¨‡¨ø?' },
    { code: 'as', name: '‡¶Ö‡¶∏‡¶Æ‡ßÄ‡¶Ø‡¶º‡¶æ', flag: 'üáÆüá≥', greeting: '‡¶®‡¶Æ‡¶∏‡ßç‡¶ï‡¶æ‡ß∞! ‡¶Æ‡¶á CareMate, ‡¶Ü‡¶™‡ßã‡¶®‡¶æ‡ß∞ AI ‡¶∏‡ßç‡¶¨‡¶æ‡¶∏‡ßç‡¶•‡ßç‡¶Ø ‡¶∏‡¶π‡¶æ‡¶Ø‡¶º‡¶ï‡•§ ‡¶Æ‡¶á ‡¶Ü‡¶™‡ßã‡¶®‡¶æ‡ß∞ ‡¶∏‡ßç‡¶¨‡¶æ‡¶∏‡ßç‡¶•‡ßç‡¶Ø ‡¶∏‡¶Æ‡ßç‡¶™‡ß∞‡ßç‡¶ï‡ßÄ‡¶Ø‡¶º ‡¶™‡ßç‡ß∞‡¶∂‡ßç‡¶®‡ß∞ ‡¶â‡¶§‡ßç‡¶§‡ß∞ ‡¶¶‡¶ø‡¶¨ ‡¶™‡¶æ‡ß∞‡ßã‡¶Å‡•§ ‡¶Ü‡¶ú‡¶ø ‡¶Æ‡¶á ‡¶Ü‡¶™‡ßã‡¶®‡¶æ‡¶ï ‡¶ï‡ßá‡¶®‡ßá‡¶ï‡ßà ‡¶∏‡¶π‡¶æ‡¶Ø‡¶º ‡¶ï‡ß∞‡¶ø‡¶¨ ‡¶™‡¶æ‡ß∞‡ßã‡¶Å?' },
    { code: 'ur', name: 'ÿßÿ±ÿØŸà', flag: 'üáÆüá≥', greeting: 'ÿßŸÑÿ≥ŸÑÿßŸÖ ÿπŸÑ€å⁄©ŸÖ! ŸÖ€å⁄∫ CareMate €ÅŸà⁄∫ÿå ÿ¢Ÿæ ⁄©ÿß AI ÿµÿ≠ÿ™ ŸÖÿπÿßŸàŸÜ€î ŸÖ€å⁄∫ ÿ¢Ÿæ ⁄©€í ÿµÿ≠ÿ™ ÿ≥€í ŸÖÿ™ÿπŸÑŸÇ ÿ≥ŸàÿßŸÑÿßÿ™ ⁄©ÿß ÿ¨Ÿàÿßÿ® ÿØ€í ÿ≥⁄©ÿ™ÿß €ÅŸà⁄∫€î ÿ¢ÿ¨ ŸÖ€å⁄∫ ÿ¢Ÿæ ⁄©€å ⁄©€åÿ≥€í ŸÖÿØÿØ ⁄©ÿ± ÿ≥⁄©ÿ™ÿß €ÅŸà⁄∫ÿü' },
    { code: 'sa', name: '‡§∏‡§Ç‡§∏‡•ç‡§ï‡•É‡§§', flag: 'üáÆüá≥', greeting: '‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Ö‡§π‡§Ç CareMate ‡§Ö‡§∏‡•ç‡§Æ‡§ø, ‡§≠‡§µ‡§§‡§É AI ‡§∏‡•ç‡§µ‡§æ‡§∏‡•ç‡§•‡•ç‡§Ø ‡§∏‡§π‡§æ‡§Ø‡§ï‡§É‡•§ ‡§Ö‡§π‡§Ç ‡§≠‡§µ‡§§‡§É ‡§∏‡•ç‡§µ‡§æ‡§∏‡•ç‡§•‡•ç‡§Ø ‡§∏‡§Æ‡•ç‡§¨‡§®‡•ç‡§ß‡§ø‡§®‡§æ‡§Ç ‡§™‡•ç‡§∞‡§∂‡•ç‡§®‡§æ‡§®‡§æ‡§Ç ‡§â‡§§‡•ç‡§§‡§∞‡§æ‡§£‡§ø ‡§¶‡§æ‡§§‡•Å‡§Ç ‡§∂‡§ï‡•ç‡§®‡•ã‡§Æ‡§ø‡•§ ‡§Ö‡§¶‡•ç‡§Ø ‡§Ö‡§π‡§Ç ‡§≠‡§µ‡§®‡•ç‡§§‡§Ç ‡§ï‡§•‡§Ç ‡§∏‡§æ‡§π‡§æ‡§Ø‡•ç‡§Ø‡§Ç ‡§ï‡§∞‡•ç‡§§‡•Å‡§Ç ‡§∂‡§ï‡•ç‡§®‡•ã‡§Æ‡§ø?' },
    { code: 'ne', name: '‡§®‡•á‡§™‡§æ‡§≤‡•Ä', flag: 'üá≥üáµ', greeting: '‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Æ CareMate ‡§π‡•Å‡§Å, ‡§§‡§™‡§æ‡§à‡§Ç‡§ï‡•ã AI ‡§∏‡•ç‡§µ‡§æ‡§∏‡•ç‡§•‡•ç‡§Ø ‡§∏‡§π‡§æ‡§Ø‡§ï‡•§ ‡§Æ ‡§§‡§™‡§æ‡§à‡§Ç‡§ï‡§æ ‡§∏‡•ç‡§µ‡§æ‡§∏‡•ç‡§•‡•ç‡§Ø ‡§∏‡§Æ‡•ç‡§¨‡§®‡•ç‡§ß‡•Ä ‡§™‡•ç‡§∞‡§∂‡•ç‡§®‡§π‡§∞‡•Ç‡§ï‡•ã ‡§ú‡§µ‡§æ‡§´ ‡§¶‡§ø‡§® ‡§∏‡§ï‡•ç‡§õ‡•Å‡•§ ‡§Ü‡§ú ‡§Æ ‡§§‡§™‡§æ‡§à‡§Ç‡§≤‡§æ‡§à ‡§ï‡§∏‡§∞‡•Ä ‡§∏‡§π‡§æ‡§Ø‡§§‡§æ ‡§ó‡§∞‡•ç‡§® ‡§∏‡§ï‡•ç‡§õ‡•Å?' },
    { code: 'si', name: '‡∑É‡∑í‡∂Ç‡∑Ñ‡∂Ω', flag: 'üá±üá∞', greeting: '‡∂Ü‡∂∫‡∑î‡∂∂‡∑ù‡∑Ä‡∂±‡∑ä! ‡∂∏‡∂∏ CareMate, ‡∂î‡∂∂‡∑ö AI ‡∑É‡∑û‡∂õ‡∑ä‚Äç‡∂∫ ‡∑É‡∑Ñ‡∑è‡∂∫‡∂ö. ‡∂∏‡∂ß ‡∂î‡∂∂‡∑ö ‡∑É‡∑û‡∂õ‡∑ä‚Äç‡∂∫ ‡∑É‡∂∏‡∑ä‡∂∂‡∂±‡∑ä‡∂∞ ‡∂¥‡∑ä‚Äç‡∂ª‡∑Å‡∑ä‡∂±‡∑Ä‡∂Ω‡∂ß ‡∂¥‡∑í‡∑Ö‡∑í‡∂≠‡∑î‡∂ª‡∑î ‡∂Ø‡∑í‡∂∫ ‡∑Ñ‡∑ê‡∂ö‡∑í‡∂∫. ‡∂Ö‡∂Ø ‡∂∏‡∂∏ ‡∂î‡∂∂‡∂ß ‡∂ö‡∑ô‡∑É‡∑ö ‡∂ã‡∂Ø‡∑Ä‡∑ä ‡∂ö‡∑Ö ‡∑Ñ‡∑ê‡∂ö‡∑í‡∂Ø?' },
  ];

  // Initialize messages with greeting in selected language
  useEffect(() => {
    const currentLang = languages.find(lang => lang.code === selectedLanguage);
    const greeting = currentLang?.greeting || languages[0].greeting;
    
    setMessages([{
      id: '1',
      role: 'assistant',
      content: greeting,
      timestamp: new Date(),
      language: selectedLanguage,
    }]);
  }, [selectedLanguage]);

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  useEffect(() => {
    // Initialize speech recognition if available
    if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
      const SpeechRecognition = (window as any).webkitSpeechRecognition || (window as any).SpeechRecognition;
      recognitionRef.current = new SpeechRecognition();
      recognitionRef.current.continuous = false;
      recognitionRef.current.interimResults = false;
      
      // Set language for speech recognition
      const langMap: { [key: string]: string } = {
        'hi': 'hi-IN',
        'en': 'en-IN',
        'bn': 'bn-IN',
        'te': 'te-IN',
        'mr': 'mr-IN',
        'ta': 'ta-IN',
        'gu': 'gu-IN',
        'kn': 'kn-IN',
        'ml': 'ml-IN',
        'pa': 'pa-IN',
        'ur': 'ur-IN',
        'or': 'or-IN',
        'as': 'as-IN',
        'ne': 'ne-NP',
        'si': 'si-LK',
      };
      
      recognitionRef.current.lang = langMap[selectedLanguage] || 'hi-IN';

      recognitionRef.current.onresult = (event: any) => {
        const transcript = event.results[0][0].transcript;
        setInputMessage(transcript);
        setIsListening(false);
      };

      recognitionRef.current.onerror = (error: any) => {
        console.error('Speech recognition error:', error);
        setIsListening(false);
      };

      recognitionRef.current.onend = () => {
        setIsListening(false);
      };
    }
  }, [selectedLanguage]);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  const handleSendMessage = async () => {
    if (!inputMessage.trim() || isLoading) return;

    const userMessage: Message = {
      id: Date.now().toString(),
      role: 'user',
      content: inputMessage,
      timestamp: new Date(),
      language: selectedLanguage,
    };

    setMessages(prev => [...prev, userMessage]);
    setInputMessage('');
    setIsLoading(true);

    try {
      // Call your backend API with Grok integration
      const response = await fetch('http://localhost:5000/api/health-chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          message: inputMessage,
          language: selectedLanguage,
          chatHistory: messages,
        }),
      });

      if (!response.ok) {
        throw new Error('Failed to get response');
      }

      const data = await response.json();
      
      const assistantMessage: Message = {
        id: (Date.now() + 1).toString(),
        role: 'assistant',
        content: data.response || getErrorMessage(selectedLanguage),
        timestamp: new Date(),
        language: selectedLanguage,
      };

      setMessages(prev => [...prev, assistantMessage]);

      // Auto-speak response if enabled
      if (autoSpeak) {
        speakText(assistantMessage.content);
      }
    } catch (error) {
      console.error('Error sending message:', error);
      const errorMessage: Message = {
        id: (Date.now() + 1).toString(),
        role: 'assistant',
        content: getErrorMessage(selectedLanguage),
        timestamp: new Date(),
      };
      setMessages(prev => [...prev, errorMessage]);
    } finally {
      setIsLoading(false);
    }
  };

  const getErrorMessage = (language: string): string => {
    const errorMessages: { [key: string]: string } = {
      'hi': '‡§ï‡•ç‡§∑‡§Æ‡§æ ‡§ï‡§∞‡•á‡§Ç, ‡§Æ‡•Å‡§ù‡•á ‡§Ö‡§≠‡•Ä ‡§ï‡§®‡•á‡§ï‡•ç‡§ü ‡§ï‡§∞‡§®‡•á ‡§Æ‡•á‡§Ç ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§π‡•ã ‡§∞‡§π‡•Ä ‡§π‡•à‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§ï‡•Å‡§õ ‡§¶‡•á‡§∞ ‡§¨‡§æ‡§¶ ‡§™‡•Å‡§®‡§É ‡§™‡•ç‡§∞‡§Ø‡§æ‡§∏ ‡§ï‡§∞‡•á‡§Ç‡•§',
      'en': 'Sorry, I\'m having trouble connecting right now. Please try again in a moment.',
      'bn': '‡¶¶‡ßÅ‡¶É‡¶ñ‡¶ø‡¶§, ‡¶Ü‡¶Æ‡¶ø ‡¶è‡¶ñ‡¶® ‡¶∏‡¶Ç‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡¶§‡ßá ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá‡•§ ‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶è‡¶ï‡¶ü‡ßÅ ‡¶™‡¶∞‡ßá ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§',
      'te': '‡∞ï‡±ç‡∞∑‡∞Æ‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø, ‡∞®‡±á‡∞®‡±Å ‡∞á‡∞™‡±ç‡∞™‡±Å‡∞°‡±Å ‡∞ï‡∞®‡±Ü‡∞ï‡±ç‡∞ü‡±ç ‡∞ö‡±á‡∞Ø‡∞°‡∞Ç‡∞≤‡±ã ‡∞∏‡∞Æ‡∞∏‡±ç‡∞Ø ‡∞é‡∞¶‡±Å‡∞∞‡±ç‡∞ï‡±ä‡∞Ç‡∞ü‡±Å‡∞®‡±ç‡∞®‡∞æ‡∞®‡±Å. ‡∞¶‡∞Ø‡∞ö‡±á‡∞∏‡∞ø ‡∞ï‡±ä‡∞Ç‡∞§ ‡∞∏‡∞Æ‡∞Ø‡∞Ç ‡∞§‡∞∞‡±ç‡∞µ‡∞æ‡∞§ ‡∞Æ‡∞≥‡±ç‡∞≤‡±Ä ‡∞™‡±ç‡∞∞‡∞Ø‡∞§‡±ç‡∞®‡∞ø‡∞Ç‡∞ö‡∞Ç‡∞°‡∞ø‡•§',
      'mr': '‡§Æ‡§æ‡§´ ‡§ï‡§∞‡§æ, ‡§Æ‡§≤‡§æ ‡§Ü‡§§‡•ç‡§§‡§æ ‡§ï‡§®‡•á‡§ï‡•ç‡§ü ‡§ï‡§∞‡§£‡•ç‡§Ø‡§æ‡§§ ‡§Ö‡§°‡§ö‡§£ ‡§Ø‡•á‡§§ ‡§Ü‡§π‡•á. ‡§ï‡•É‡§™‡§Ø‡§æ ‡§•‡•ã‡§°‡•ç‡§Ø‡§æ ‡§µ‡•á‡§≥‡§æ‡§®‡•á ‡§™‡•Å‡§®‡•ç‡§π‡§æ ‡§™‡•ç‡§∞‡§Ø‡§§‡•ç‡§® ‡§ï‡§∞‡§æ.',
      'ta': '‡ÆÆ‡Æ©‡Øç‡Æ©‡Æø‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç, ‡Æé‡Æ©‡Æï‡Øç‡Æï‡ØÅ ‡Æá‡Æ™‡Øç‡Æ™‡Øã‡Æ§‡ØÅ ‡Æá‡Æ£‡Øà‡Æï‡Øç‡Æï ‡Æö‡Æø‡Æï‡Øç‡Æï‡Æ≤‡Øç ‡Æâ‡Æ≥‡Øç‡Æ≥‡Æ§‡ØÅ. ‡Æ§‡ÆØ‡Æµ‡ØÅ‡Æö‡ØÜ‡ÆØ‡Øç‡Æ§‡ØÅ ‡Æö‡Æø‡Æ±‡Æø‡Æ§‡ØÅ ‡Æ®‡Øá‡Æ∞‡ÆÆ‡Øç ‡Æï‡Æ¥‡Æø‡Æ§‡Øç‡Æ§‡ØÅ ‡ÆÆ‡ØÄ‡Æ£‡Øç‡Æü‡ØÅ‡ÆÆ‡Øç ‡ÆÆ‡ØÅ‡ÆØ‡Æ±‡Øç‡Æö‡Æø‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç.',
      'gu': '‡™Æ‡™æ‡™´ ‡™ï‡™∞‡™∂‡´ã, ‡™Æ‡™®‡´á ‡™Ö‡™§‡´ç‡™Ø‡™æ‡™∞‡´á ‡™ï‡™®‡´á‡™ï‡´ç‡™ü ‡™ï‡™∞‡™µ‡™æ‡™Æ‡™æ‡™Ç ‡™Æ‡´Å‡™∂‡´ç‡™ï‡´á‡™≤‡´Ä ‡™Ü‡™µ‡´Ä ‡™∞‡™π‡´Ä ‡™õ‡´á. ‡™ï‡´É‡™™‡™æ ‡™ï‡™∞‡´Ä‡™®‡´á ‡™•‡´ã‡™°‡´Ä ‡™µ‡™æ‡™∞ ‡™™‡™õ‡´Ä ‡™´‡™∞‡´Ä ‡™™‡´ç‡™∞‡™Ø‡™æ‡™∏ ‡™ï‡™∞‡´ã.',
      'kn': '‡≤ï‡≥ç‡≤∑‡≤Æ‡≤ø‡≤∏‡≤ø, ‡≤®‡≤®‡≤ó‡≥Ü ‡≤à‡≤ó ‡≤∏‡≤Ç‡≤™‡≤∞‡≥ç‡≤ï‡≤ø‡≤∏‡≤≤‡≥Å ‡≤§‡≥ä‡≤Ç‡≤¶‡≤∞‡≥Ü‡≤Ø‡≤æ‡≤ó‡≥Å‡≤§‡≥ç‡≤§‡≤ø‡≤¶‡≥Ü. ‡≤¶‡≤Ø‡≤µ‡≤ø‡≤ü‡≥ç‡≤ü‡≥Å ‡≤∏‡≥ç‡≤µ‡≤≤‡≥ç‡≤™ ‡≤∏‡≤Æ‡≤Ø‡≤¶ ‡≤®‡≤Ç‡≤§‡≤∞ ‡≤Æ‡≤§‡≥ç‡≤§‡≥Ü ‡≤™‡≥ç‡≤∞‡≤Ø‡≤§‡≥ç‡≤®‡≤ø‡≤∏‡≤ø.',
      'ml': '‡¥ï‡µç‡¥∑‡¥Æ‡¥ø‡¥ï‡µç‡¥ï‡¥£‡¥Ç, ‡¥é‡¥®‡¥ø‡¥ï‡µç‡¥ï‡µç ‡¥á‡¥™‡µç‡¥™‡µã‡µæ ‡¥ï‡¥£‡¥ï‡µç‡¥±‡µç‡¥±‡µç ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡¥æ‡µª ‡¥™‡µç‡¥∞‡¥∂‡µç‡¥®‡¥Æ‡µÅ‡¥£‡µç‡¥ü‡µç. ‡¥¶‡¥Ø‡¥µ‡¥æ‡¥Ø‡¥ø ‡¥ï‡µÅ‡¥±‡¥ö‡µç‡¥ö‡µç ‡¥∏‡¥Æ‡¥Ø‡¥§‡µç‡¥§‡¥ø‡¥®‡µç ‡¥∂‡µá‡¥∑‡¥Ç ‡¥µ‡µÄ‡¥£‡µç‡¥ü‡µÅ‡¥Ç ‡¥∂‡µç‡¥∞‡¥Æ‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥ï.',
      'pa': '‡®Æ‡®æ‡®´‡®º ‡®ï‡®∞‡©ã, ‡®Æ‡©à‡®®‡©Ç‡©∞ ‡®π‡©Å‡®£ ‡®ï‡®®‡©à‡®ï‡®ü ‡®ï‡®∞‡®® ‡®µ‡®ø‡©±‡®ö ‡®∏‡®Æ‡©±‡®∏‡®ø‡®Ü ‡®π‡©ã ‡®∞‡®π‡©Ä ‡®π‡©à‡•§ ‡®ï‡®ø‡®∞‡®™‡®æ ‡®ï‡®∞‡®ï‡©á ‡®•‡©ã‡©ú‡©ç‡®π‡©Ä ‡®¶‡©á‡®∞ ‡®¨‡®æ‡®Ö‡®¶ ‡®¶‡©Å‡®¨‡®æ‡®∞‡®æ ‡®ï‡©ã‡®∏‡®º‡®ø‡®∏‡®º ‡®ï‡®∞‡©ã‡•§',
      'or': '‡¨¶‡≠Å‡¨É‡¨ñ‡¨ø‡¨§, ‡¨Æ‡≠ã‡¨∞ ‡¨¨‡¨∞‡≠ç‡¨§‡≠ç‡¨§‡¨Æ‡¨æ‡¨® ‡¨∏‡¨Ç‡¨Ø‡≠ã‡¨ó ‡¨ï‡¨∞‡¨ø‡¨¨‡¨æ‡¨∞‡≠á ‡¨∏‡¨Æ‡¨∏‡≠ç‡≠ü‡¨æ ‡¨π‡≠á‡¨â‡¨õ‡¨ø‡•§ ‡¨¶‡≠ü‡¨æ‡¨ï‡¨∞‡¨ø ‡¨ï‡¨ø‡¨õ‡¨ø ‡¨∏‡¨Æ‡≠ü ‡¨™‡¨∞‡≠á ‡¨™‡≠Å‡¨£‡¨ø ‡¨ö‡≠á‡¨∑‡≠ç‡¨ü‡¨æ ‡¨ï‡¨∞‡¨®‡≠ç‡¨§‡≠Å‡•§',
      'as': '‡¶¶‡ßÅ‡¶É‡¶ñ‡¶ø‡¶§, ‡¶Æ‡ßã‡ß∞ ‡¶è‡¶§‡¶ø‡¶Ø‡¶º‡¶æ ‡¶∏‡¶Ç‡¶Ø‡ßã‡¶ó ‡¶ï‡ß∞‡¶æ‡¶§ ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶π‡ßà‡¶õ‡ßá‡•§ ‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡ß∞‡¶π ‡¶ï‡ß∞‡¶ø ‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶∏‡¶Æ‡¶Ø‡¶º‡ß∞ ‡¶™‡¶ø‡¶õ‡¶§ ‡¶™‡ßÅ‡¶®‡ß∞ ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡ß∞‡¶ï‡•§',
      'ur': 'ŸÖÿπÿ∞ÿ±ÿ™ÿå ŸÖÿ¨⁄æ€í ÿßÿ®⁄æ€å ⁄©ŸÜ⁄©Ÿπ ⁄©ÿ±ŸÜ€í ŸÖ€å⁄∫ ŸÖÿ≥ÿ¶ŸÑ€Å €ÅŸà ÿ±€Åÿß €Å€í€î ÿ®ÿ±ÿß€Å ⁄©ÿ±ŸÖ ÿ™⁄æŸà⁄ë€å ÿØ€åÿ± ÿ®ÿπÿØ ÿØŸàÿ®ÿßÿ±€Å ⁄©Ÿàÿ¥ÿ¥ ⁄©ÿ±€å⁄∫€î',
      'sa': '‡§ï‡•ç‡§∑‡§Æ‡•ç‡§Ø‡§§‡§æ‡§Æ‡•ç, ‡§Æ‡§Æ ‡§Ö‡§ß‡•Å‡§®‡§æ ‡§∏‡§Æ‡•ç‡§¨‡§®‡•ç‡§ß‡•á ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§Ö‡§∏‡•ç‡§§‡§ø‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§ï‡§ø‡§û‡•ç‡§ö‡§ø‡§§‡•ç ‡§ï‡§æ‡§≤‡§æ‡§§‡•ç ‡§™‡•Å‡§®‡§É ‡§™‡•ç‡§∞‡§Ø‡§§‡•ç‡§®‡§Ç ‡§ï‡•Å‡§∞‡•ç‡§µ‡§®‡•ç‡§§‡•Å‡•§',
      'ne': '‡§Æ‡§æ‡§´ ‡§ó‡§∞‡•ç‡§®‡•Å‡§π‡•ã‡§∏‡•ç, ‡§Æ‡§≤‡§æ‡§à ‡§Ö‡§π‡§ø‡§≤‡•á ‡§ú‡§°‡§æ‡§® ‡§ó‡§∞‡•ç‡§® ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§≠‡§á‡§∞‡§π‡•á‡§ï‡•ã ‡§õ‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§ï‡•á‡§π‡•Ä ‡§∏‡§Æ‡§Ø ‡§™‡§õ‡§ø ‡§´‡•á‡§∞‡§ø ‡§™‡•ç‡§∞‡§Ø‡§æ‡§∏ ‡§ó‡§∞‡•ç‡§®‡•Å‡§π‡•ã‡§∏‡•ç‡•§',
      'si': '‡∑É‡∂∏‡∑è‡∑Ä‡∂±‡∑ä‡∂±, ‡∂∏‡∂ß ‡∂Ø‡∑ê‡∂±‡∑ä ‡∑É‡∂∏‡∑ä‡∂∂‡∂±‡∑ä‡∂∞ ‡∑Ä‡∑ì‡∂∏‡∂ß ‡∂ú‡∑ê‡∂ß‡∂Ω‡∑î‡∑Ä‡∂ö‡∑ä ‡∂≠‡∑í‡∂∂‡∑ö. ‡∂ö‡∂ª‡∑î‡∂´‡∑è‡∂ö‡∂ª ‡∂ß‡∑í‡∂ö ‡∑Ä‡∑ö‡∂Ω‡∑è‡∑Ä‡∂ö‡∑í‡∂±‡∑ä ‡∂±‡∑ê‡∑Ä‡∂≠ ‡∂ã‡∂≠‡∑ä‡∑É‡∑è‡∑Ñ ‡∂ö‡∂ª‡∂±‡∑ä‡∂±.',
    };
    
    return errorMessages[language] || errorMessages['hi'];
  };

  // Enhanced voice input with proper toggle functionality
  const handleVoiceInput = async () => {
    if (!voiceInputEnabled) return;

    if (isListening) {
      // Stop listening when clicked again
      if (recognitionRef.current) {
        recognitionRef.current.stop();
      }
      if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {
        mediaRecorderRef.current.stop();
      }
      setIsListening(false);
      return;
    }

    try {
      // Try browser speech recognition first
      if (recognitionRef.current) {
        setIsListening(true);
        recognitionRef.current.start();
      } else {
        // Fallback to MediaRecorder for better quality
        const stream = await navigator.mediaDevices.getUserMedia({ 
          audio: {
            sampleRate: 16000,
            channelCount: 1,
            echoCancellation: true,
            noiseSuppression: true,
          }
        });
        
        const mediaRecorder = new MediaRecorder(stream, {
          mimeType: 'audio/webm;codecs=opus'
        });
        mediaRecorderRef.current = mediaRecorder;
        audioChunksRef.current = [];

        mediaRecorder.ondataavailable = (event) => {
          audioChunksRef.current.push(event.data);
        };

        mediaRecorder.onstop = async () => {
          const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/webm' });
          try {
            const transcript = await transcribeAudio(audioBlob);
            setInputMessage(transcript);
          } catch (error) {
            console.error('Transcription error:', error);
          }
          stream.getTracks().forEach(track => track.stop());
          setIsListening(false);
        };

        setIsListening(true);
        mediaRecorder.start();

        // Auto-stop after 30 seconds
        setTimeout(() => {
          if (mediaRecorder.state === 'recording') {
            mediaRecorder.stop();
          }
        }, 30000);
      }
    } catch (error) {
      console.error('Voice input error:', error);
      setIsListening(false);
    }
  };

  const transcribeAudio = async (audioBlob: Blob): Promise<string> => {
    const formData = new FormData();
    formData.append('audio', audioBlob, 'audio.webm');
    
    const response = await fetch('http://localhost:5000/api/transcribe', {
      method: 'POST',
      body: formData,
    });

    if (!response.ok) {
      throw new Error('Transcription failed');
    }

    const data = await response.json();
    return data.transcript || '';
  };

  const speakText = (text: string) => {
    if ('speechSynthesis' in window) {
      // Stop any ongoing speech
      speechSynthesis.cancel();
      
      const utterance = new SpeechSynthesisUtterance(text);
      
      // Set language for speech synthesis
      const langMap: { [key: string]: string } = {
        'hi': 'hi-IN',
        'en': 'en-IN',
        'bn': 'bn-IN',
        'te': 'te-IN',
        'mr': 'mr-IN',
        'ta': 'ta-IN',
        'gu': 'gu-IN',
        'kn': 'kn-IN',
        'ml': 'ml-IN',
        'pa': 'pa-IN',
        'ur': 'ur-IN',
        'or': 'or-IN',
        'as': 'as-IN',
        'ne': 'ne-NP',
        'si': 'si-LK',
      };
      
      utterance.lang = langMap[selectedLanguage] || 'hi-IN';
      utterance.rate = 0.9;
      utterance.pitch = 1;
      
      utterance.onstart = () => setIsSpeaking(true);
      utterance.onend = () => setIsSpeaking(false);
      utterance.onerror = () => setIsSpeaking(false);
      
      speechSynthesis.speak(utterance);
    }
  };

  const stopSpeaking = () => {
    if ('speechSynthesis' in window) {
      speechSynthesis.cancel();
      setIsSpeaking(false);
    }
  };

  const clearChat = () => {
    const currentLang = languages.find(lang => lang.code === selectedLanguage);
    const greeting = currentLang?.greeting || languages[0].greeting;
    
    setMessages([{
      id: '1',
      role: 'assistant',
      content: greeting,
      timestamp: new Date(),
      language: selectedLanguage,
    }]);
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
  };

  const currentLanguage = languages.find(lang => lang.code === selectedLanguage) || languages[0];

  if (!isOpen) {
    return (
      <div className="fixed bottom-6 right-6 z-50">
        <button
          onClick={onToggle}
          className="bg-primary-500 hover:bg-primary-600 text-white rounded-full p-4 shadow-lg transition-all duration-300 hover:scale-110 animate-pulse"
        >
          <Bot className="h-6 w-6" />
        </button>
      </div>
    );
  }

  return (
    <div className="fixed bottom-6 right-6 z-50">
      <div className={`bg-white rounded-2xl shadow-2xl border border-neutral-200 transition-all duration-300 ${
        isMinimized ? 'w-80 h-16' : 'w-96 h-[600px]'
      }`}>
        {/* Header */}
        <div className="flex items-center justify-between p-4 border-b border-neutral-200 bg-gradient-to-r from-primary-500 to-primary-600 text-white rounded-t-2xl">
          <div className="flex items-center space-x-3">
            <div className="h-8 w-8 bg-white/20 rounded-full flex items-center justify-center">
              <Bot className="h-5 w-5" />
            </div>
            <div>
              <h3 className="font-semibold text-sm">CareMate AI</h3>
              <p className="text-xs opacity-90">{currentLanguage.name} ‡§∏‡•ç‡§µ‡§æ‡§∏‡•ç‡§•‡•ç‡§Ø ‡§∏‡§π‡§æ‡§Ø‡§ï</p>
            </div>
          </div>
          
          <div className="flex items-center space-x-2">
            {/* Language Selector */}
            <select
              value={selectedLanguage}
              onChange={(e) => setSelectedLanguage(e.target.value)}
              className="bg-white/20 text-white text-xs rounded px-2 py-1 border-0 focus:outline-none focus:ring-1 focus:ring-white/50"
            >
              {languages.map((lang) => (
                <option key={lang.code} value={lang.code} className="text-neutral-800">
                  {lang.flag} {lang.name}
                </option>
              ))}
            </select>
            
            <button
              onClick={() => setIsMinimized(!isMinimized)}
              className="p-1 hover:bg-white/20 rounded transition-colors"
            >
              {isMinimized ? <Maximize2 className="h-4 w-4" /> : <Minimize2 className="h-4 w-4" />}
            </button>
            
            <button
              onClick={onToggle}
              className="p-1 hover:bg-white/20 rounded transition-colors"
            >
              <X className="h-4 w-4" />
            </button>
          </div>
        </div>

        {!isMinimized && (
          <>
            {/* Controls */}
            <div className="flex items-center justify-between p-3 bg-neutral-50 border-b border-neutral-200">
              <div className="flex items-center space-x-2">
                <button
                  onClick={() => setVoiceInputEnabled(!voiceInputEnabled)}
                  className={`p-2 rounded-lg transition-colors ${
                    voiceInputEnabled 
                      ? 'bg-primary-100 text-primary-600' 
                      : 'bg-neutral-200 text-neutral-600 hover:bg-neutral-300'
                  }`}
                  title={voiceInputEnabled ? 'Voice input enabled' : 'Voice input disabled'}
                >
                  {voiceInputEnabled ? <Mic className="h-4 w-4" /> : <MicOff className="h-4 w-4" />}
                </button>
                
                <button
                  onClick={() => setAutoSpeak(!autoSpeak)}
                  className={`p-2 rounded-lg transition-colors ${
                    autoSpeak 
                      ? 'bg-secondary-100 text-secondary-600' 
                      : 'bg-neutral-200 text-neutral-600 hover:bg-neutral-300'
                  }`}
                  title={autoSpeak ? 'Auto-speak enabled' : 'Auto-speak disabled'}
                >
                  {autoSpeak ? <Volume2 className="h-4 w-4" /> : <VolumeX className="h-4 w-4" />}
                </button>

                {isSpeaking && (
                  <button
                    onClick={stopSpeaking}
                    className="p-2 rounded-lg bg-error-100 text-error-600 hover:bg-error-200 transition-colors"
                    title="Stop speaking"
                  >
                    <Square className="h-4 w-4" />
                  </button>
                )}
              </div>
              
              <button
                onClick={clearChat}
                className="p-2 rounded-lg bg-neutral-200 text-neutral-600 hover:bg-neutral-300 transition-colors"
                title="Clear chat"
              >
                <RefreshCw className="h-4 w-4" />
              </button>
            </div>

            {/* Messages */}
            <div className="flex-1 overflow-y-auto p-4 space-y-4 h-[400px]">
              {messages.map((message) => (
                <div
                  key={message.id}
                  className={`flex ${message.role === 'user' ? 'justify-end' : 'justify-start'}`}
                >
                  <div
                    className={`max-w-[80%] rounded-2xl px-4 py-2 ${
                      message.role === 'user'
                        ? 'bg-primary-500 text-white'
                        : 'bg-neutral-100 text-neutral-800'
                    }`}
                  >
                    <div className="flex items-start space-x-2">
                      {message.role === 'assistant' && (
                        <Bot className="h-4 w-4 mt-1 text-primary-500 flex-shrink-0" />
                      )}
                      {message.role === 'user' && (
                        <User className="h-4 w-4 mt-1 text-white flex-shrink-0" />
                      )}
                      <div className="flex-1 min-w-0">
                        <p className="text-sm leading-relaxed break-words">{message.content}</p>
                        <p className={`text-xs mt-1 ${
                          message.role === 'user' ? 'text-primary-100' : 'text-neutral-500'
                        }`}>
                          {message.timestamp.toLocaleTimeString([], { 
                            hour: '2-digit', 
                            minute: '2-digit' 
                          })}
                        </p>
                      </div>
                      {message.role === 'assistant' && (
                        <button
                          onClick={() => speakText(message.content)}
                          className="p-1 hover:bg-neutral-200 rounded transition-colors flex-shrink-0"
                          disabled={isSpeaking}
                        >
                          <Volume2 className="h-3 w-3 text-neutral-500" />
                        </button>
                      )}
                    </div>
                  </div>
                </div>
              ))}
              
              {isLoading && (
                <div className="flex justify-start">
                  <div className="bg-neutral-100 rounded-2xl px-4 py-2">
                    <div className="flex items-center space-x-2">
                      <Bot className="h-4 w-4 text-primary-500" />
                      <div className="flex space-x-1">
                        <div className="w-2 h-2 bg-primary-500 rounded-full animate-bounce"></div>
                        <div className="w-2 h-2 bg-primary-500 rounded-full animate-bounce" style={{ animationDelay: '0.1s' }}></div>
                        <div className="w-2 h-2 bg-primary-500 rounded-full animate-bounce" style={{ animationDelay: '0.2s' }}></div>
                      </div>
                    </div>
                  </div>
                </div>
              )}
              
              <div ref={messagesEndRef} />
            </div>

            {/* Input */}
            <div className="p-4 border-t border-neutral-200">
              <div className="flex space-x-2">
                {/* Voice Input Button */}
                {voiceInputEnabled && (
                  <button
                    onClick={handleVoiceInput}
                    disabled={isLoading}
                    className={`p-3 rounded-full transition-all duration-300 flex-shrink-0 ${
                      isListening
                        ? 'bg-error-500 text-white animate-pulse shadow-lg'
                        : 'bg-primary-500 text-white hover:bg-primary-600 shadow-md hover:shadow-lg'
                    }`}
                    title={isListening ? 'Click to stop listening' : 'Click to start voice input'}
                  >
                    {isListening ? <MicOff className="h-5 w-5" /> : <Mic className="h-5 w-5" />}
                  </button>
                )}
                
                {/* Text Input */}
                <input
                  ref={inputRef}
                  type="text"
                  value={inputMessage}
                  onChange={(e) => setInputMessage(e.target.value)}
                  onKeyPress={handleKeyPress}
                  placeholder={`${currentLanguage.name} ‡§Æ‡•á‡§Ç ‡§Ö‡§™‡§®‡§æ ‡§∏‡•ç‡§µ‡§æ‡§∏‡•ç‡§•‡•ç‡§Ø ‡§™‡•ç‡§∞‡§∂‡•ç‡§® ‡§≤‡§ø‡§ñ‡•á‡§Ç...`}
                  className="flex-1 px-4 py-2 border border-neutral-300 rounded-full focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
                  disabled={isLoading || isListening}
                />
                
                {/* Send Button */}
                <Button
                  onClick={handleSendMessage}
                  disabled={!inputMessage.trim() || isLoading || isListening}
                  className="rounded-full px-4 flex-shrink-0"
                  rightIcon={<Send className="h-4 w-4" />}
                >
                  Send
                </Button>
              </div>
              
              {/* Voice Input Status */}
              {isListening && (
                <div className="mt-2 flex items-center justify-center text-sm text-primary-600">
                  <div className="flex items-center space-x-2">
                    <div className="w-2 h-2 bg-error-500 rounded-full animate-pulse"></div>
                    <span>‡§∏‡•Å‡§® ‡§∞‡§π‡§æ ‡§π‡•Ç‡§Ç... ‡§∞‡•ã‡§ï‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Æ‡§æ‡§á‡§ï ‡§¨‡§ü‡§® ‡§¶‡§¨‡§æ‡§è‡§Ç</span>
                  </div>
                </div>
              )}
            </div>
          </>
        )}
      </div>
    </div>
  );
};

export default AIHealthAssistant;